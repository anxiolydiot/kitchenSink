"use strict";describe("socketFactory",function(){beforeEach(module("btford.socket-io"));var e,t,n,o,c,i;beforeEach(inject(function(l,s,a,r){o=s,n=r,t=a.$new(),i=jasmine.createSpy("emitSpy"),c=io.connect(),e=l({ioSocket:c,scope:t})})),describe("#on",function(){it("should apply asynchronously",function(){e.on("event",i),c.emit("event"),expect(i).not.toHaveBeenCalled(),n.flush(),expect(i).toHaveBeenCalled()})}),describe("#disconnect",function(){it("should call the underlying socket.disconnect",function(){c.disconnect=i,e.disconnect(),expect(i).toHaveBeenCalled()})}),describe("#connect",function(){it("should call the underlying socket.connect",function(){c.connect=i,e.connect(),expect(i).toHaveBeenCalled()})}),describe("#once",function(){it("should apply asynchronously",function(){e.once("event",i),c.emit("event"),expect(i).not.toHaveBeenCalled(),n.flush(),expect(i).toHaveBeenCalled()}),it("should only run once",function(){var t=0;e.once("event",function(){t+=1}),c.emit("event"),c.emit("event"),n.flush(),expect(t).toBe(1)})}),describe("#emit",function(){it("should call the delegate socket's emit",function(){spyOn(c,"emit"),e.emit("event",{foo:"bar"}),expect(c.emit).toHaveBeenCalled()}),it("should allow multiple data arguments",function(){spyOn(c,"emit"),e.emit("event","x","y"),expect(c.emit).toHaveBeenCalledWith("event","x","y")}),it("should wrap the callback with multiple data arguments",function(){spyOn(c,"emit"),e.emit("event","x","y",i),expect(c.emit.mostRecentCall.args[3]).toNotBe(i),c.emit.mostRecentCall.args[3](),expect(i).not.toHaveBeenCalled(),n.flush(),expect(i).toHaveBeenCalled()})}),describe("#removeListener",function(){it("should not call after removing an event",function(){e.on("event",i),e.removeListener("event",i),c.emit("event"),expect(o.deferredFns.length).toBe(0)})}),describe("#removeAllListeners",function(){it("should not call after removing listeners for an event",function(){e.on("event",i),e.removeAllListeners("event"),c.emit("event"),expect(o.deferredFns.length).toBe(0)}),it("should not call after removing all listeners",function(){e.on("event",i),e.on("event2",i),e.removeAllListeners(),c.emit("event"),c.emit("event2"),expect(o.deferredFns.length).toBe(0)})}),describe("#forward",function(){it("should forward events",function(){e.forward("event"),t.$on("socket:event",i),c.emit("event"),n.flush(),expect(i).toHaveBeenCalled()}),it("should forward an array of events",function(){e.forward(["e1","e2"]),t.$on("socket:e1",i),t.$on("socket:e2",i),c.emit("e1"),c.emit("e2"),n.flush(),expect(i.callCount).toBe(2)}),it("should remove watchers when the scope is removed",function(){e.forward("event"),t.$on("socket:event",i),c.emit("event"),n.flush(),expect(i).toHaveBeenCalled(),t.$destroy(),i.reset(),c.emit("event"),expect(i).not.toHaveBeenCalled()}),it("should use the specified prefix",inject(function(e){var o=e({ioSocket:c,scope:t,prefix:"custom:"});o.forward("event"),t.$on("custom:event",i),c.emit("event"),n.flush(),expect(i).toHaveBeenCalled()})),it("should use an empty prefix if specified",inject(function(e){var o=e({ioSocket:c,scope:t,prefix:""});o.forward("event"),t.$on("event",i),c.emit("event"),n.flush(),expect(i).toHaveBeenCalled()})),it("should forward to the specified scope when one is provided",function(){var o=t.$new();spyOn(o,"$broadcast"),e.forward("event",o),t.$on("socket:event",i),c.emit("event"),n.flush(),expect(o.$broadcast).toHaveBeenCalled()}),it("should pass all arguments to scope.$on",function(){e.forward("event"),t.$on("socket:event",i),c.emit("event",1,2,3),n.flush(),expect(i.calls[0].args.slice(1)).toEqual([1,2,3])})})});